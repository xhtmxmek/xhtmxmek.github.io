[ { "title": "레이어드 머티리얼 만들기", "url": "/posts/layeredMaterialPractice/", "categories": "Unreal Engine, material", "tags": "머티리얼", "date": "2024-11-04 00:00:00 +0900", "snippet": "출처 : ue5 레이어드 머티리얼 만들기두개의 머티리얼 레이어(함수) 만들기. Chrome, Snow를 나타내는 레이어두 머티리얼을 마스터 머티리얼에서 혼합머티리얼 인스턴스로 파라미터 값을 조정. 시작용 컨텐츠에 있는 의자 메쉬에 입혀서 최종 출력" }, { "title": "머티리얼 레이어", "url": "/posts/MaterialLayer/", "categories": "Unreal Engine, material", "tags": "머티리얼", "date": "2024-11-04 00:00:00 +0900", "snippet": "출처 : ue5 머티리얼 레이어레이어드 머티리얼과 유사하지만 더 간단하고 유연성이 좋다.기존 레이어드 머티리얼은 머티리얼 노드 그래프에서 직접 수정헀어야 되지만, 머티리얼 레이어에서는 아티스트가 머티리얼 인스턴스 에디터 탭에서 빠르고 쉽게 인스턴스 레이어를 교체할 수 있다. 이 워크플로를 사용하면 머티리얼 레이어가 인스턴스 에디터에 노출되므로 레이어드 머티리얼을 커스터마이징하는데 필요한 기술적 지식과 시간이 크게 감소한다.주요 장점머티리얼 레이어의 주요 장점 중 하나는 복잡성을 줄여주고 편집이 쉽게 해준다. 기존 머티리얼이나 레이어드 머티리얼로 만들 수 있는 로직을 유연하고, 덜 복잡하고, 쉽게 제어할 수 있게 된다.아래의 그림은 그래프 기반 접근법의 기존 레이어드 머티리얼과 GUI 기반 머티리얼 레이어를 사용한 머티리얼의 차이를 나타낸 것이다. 머티리얼 레이어의 경우 베이스 머티리얼에 필요한 작업량이 적고 작업과 기능은 애셋 자체에서 수행된다.머티리얼 함수 방식은, 함수 내부에서 정의된 parameter를 머티리얼 인스턴스에서 볼 수 없다. 즉 베이스 머티리얼에서 함수의 입력으로 동일한 별도의 파라메터를 만들어서 함수 입력으로 넣어줘야 인스턴스에서도 볼 수 있게 된다.반면 머티리얼 레이어 방식은, 머티리얼 인스턴스 입장에서는 베이스 머티리얼의 레이어 스택에 추가된 레이어에서 파라메터를 참조한다. 따라서 베이스 머티리얼에서 기존 함수 방식처럼 파라메터 복제를 할 필요가 없다.머티리얼 레이어나 머티리얼 레이어 블랜드 애셋 을 열었을때 표시되는 노드 그래프는 머티리얼 에디터의 그래프와 비슷하다. 어트리뷰트를 파라메터 하고 로직 구성한 뒤, 머티리얼에서는 해당 애셋을 참조만 하면된다.머티리얼 레이어 블렌드 에셋은 레이어들의 마스킹을 제어하는 데 사용된다. 각 레이어마다 별개의 블렌드를 가질 수 있다. 항상 블렌드 에셋이 없는 최상단의 레이어가 아래의 모든 레이어를 오버라이드 한다. 머티리얼 레이어처럼 그래프 방식이다.별도의 파라메터를 통해 마스킹 로직을 구성 가능하고, 여러 머티리얼에 걸쳐 인스턴싱하거나 재사용 할 수 있다.머티리얼 레이어 사용하기" }, { "title": "레이어드 머티리얼", "url": "/posts/MaterialLayer/", "categories": "Unreal Engine, material", "tags": "머티리얼", "date": "2024-10-30 00:00:00 +0900", "snippet": "참고: ue5 레이어드 머티리얼개요레이어드 머티리얼(Layered Materials) 은 일련의 서브 머티리얼(레이어)이 포함된 머티리얼을 만든 다음 마스크와 같은 픽셀당 연산으로 오브젝트의 표면에 배치할 수 있다. 표면의 복잡한 블렌딩을 처리하는데 적합.아래 이미지에서 가장 오른쪽의 로켓은 크롬, 알류미늄, 구리 부분에 별도의 레이어를 사용했음. 머티리얼에서 픽셀 단위로 블렌딩. 왼쪽 세개는 레이어 없이 단일 재질.레이어드 머티리얼 기능은 머티리얼 함수의 확장. 머티리얼 함수 내에서 Make Material Attruibutes와 Break Material Attribute 노드를 사용하여 출력. 베이스 머티리얼에서 이 함수를 호출하여 레이어 블렌드 사용하여 블렌딩.위 이미지처럼 머티리얼 함수 내에서 Make Material Attribute를 사용하여 출력하고, 블렌드 머티리얼에서 레이어로 사용하여 다른 레이어(머티리얼 함수)와 블렌드 가능.작업 프로세스는 다음과 같다. 머티리얼 함수를 만들어서 로직을 구성하고 Make Material Attribute 노드, 함수 출력에 연결하여 저장. 다른 머티리얼 함수 레이어에서 이 과정 반복. 새 머티리얼을 만들고 만들어진 레이어들을 Material Layer Blend 를 이용하여 블렌딩.주요 장점레이어나 함수 없이 기존 머티리얼 그래프로도 레이어드 머티리얼 효과를 낼 수 있지만, 노드 네트워크가 복잡해지게 된다.반면 레이어드 머티리얼을 사용하면 블렌딩이 쉬워지고 아티스트의 수정과 디버깅도 간편해진다.레이어드 머티리얼의 또 다른 장점은 머티리얼 함수를 사용하므로 각 레이어를 재사용 할 수 있다. 표면을 정의하는 일종의 라이브러리 세트를 다양하게 조합해서 만들어 놓을 수 있다.블렌드 타입머티리얼 에디터 팔레트의 머티리얼 함수 목록에는 다양한 머티리얼 레이어 블렌드 함수가 있다. 레이어에서 노멀만 출력한다던지, 이미시브 텍스처를 머티리얼 레이어에 블렌딩 한다던지, 두 레이어의 모든 속성을 블렌드 한다던지다양한 효과를 지닌 블렌드 타입이 있다. 예시로 몇가지 추리자면 MatLayerBlend_Simple 두개의 머티리얼 레이어를 간단한 선형보간으로 블렌딩. 노멀은 블렌딩하지않고, 베이스 머티리얼의 노멀을 유지. MatLayerBlend_Break_normal 입력된 머티리얼 레이어에서 노멀을 출력함 MatLayerBlend_Emissive 이미시브 텍스처를 머티리얼 레이어에 블렌딩레이어드 머티리얼 인스턴싱하기인스턴싱을 위해 머티리얼을 파라미터화 하려면 함수 입력(Function Input) 표현식을 만들고 상위 머티리얼에서 이 입력에 파라미터를 연결함. 머티리얼 파라미터(스칼라 파라미터, 벡터 파라미터) 머티리얼 레이어(함수) 함수 입력 표현식 머티리얼 레이어를 정의하는 네트워크 함수 출력 최종 머티리얼주의사항레이어 함수에 사용되는 머티리얼 자체가 복잡한 경우, 퍼포먼스를 수행하기에 무거울 수 있음.일반적으로 오브젝트에 여러 종류의 표면을 적용하고 싶을때마다 레이어드 머티리얼을 사용하는 것보다 지오메트리 수준에서 레이어를 분리하는 것이 더 효율적인 경우가 많음. 드로콜 자체는 더 늘어나지만 효율성은 훨씬 더 높음.여러개의 개별 머티리얼을 하나로 압축하면 드로콜이 줄어들지만 모바일 플랫폼에서 사용하기에는 지나치게 무거워짐." }, { "title": "RealTimeRendering", "url": "/posts/rtr/", "categories": "Graphics_3D, Real Time Rendering", "tags": "TAG", "date": "2024-10-02 00:00:00 +0900", "snippet": "3장 그래픽 처리 장치모든 처리가 해결해야 하는 문제는 지연(latency)이다. 기본 개념은 처리할 정보가 처리장치에서 멀어질수록 대기 시간이 길어진다.(예를 들어 컴퓨트 셰이더의 경우, 장치메모리 &amp;gt; 공유 메모리 &amp;gt; 레지스터 순으로 속도가 빨라진다).데이터 검색을 기다려서 처리장치가 정지 대기(stall)가 되어 성능이 떨어지는 것이 요점이다.데이터 병렬 아키텍처CPU는 제한된 SIMD 벡터 처리를 제외하고는 대부분 직렬 방식으로 실행. 캐시나 분기예측 등으로 정지 대기를 방지함.GPU는 CPU와 다르게 수천개의 코어로 이루어져 있음. 대규묘 유사한 데이터 집합을 병렬로 처리함. cpu와 다르게 캐시 메모리와 제어 로직 전용 칩 영역이 적어서 지연 시간이 cpu보다 높다.단일 코어를 지닌 gpu에서, 2000개의 프래그먼트를 처리한다고 가정하자. 셰이더 프로그램 역시 2000번실행된다. 텍스처 샘플링 할떄, 메모리 fetch 연산은 수백에서 수천 클럭 주기를 소모하며 이 시간동안 GPU 처리장치는 아무것도 하지 않음. 이 시점 셰이더 프로세서는 반환 끝날때까지 대기.이를 개선하기 위해 정지(stall) 명령을 만나면 2번째 프래그먼트로 전환하여 셰이더 프로그램 실행. 산술연산 실행하고 텍스처 페치 만나면 다시 멈추고 3번째 프래그먼트로 감. 첫번째 프래그먼트 인출이 끝나면 첫번째로 다시 되돌아감.nvidia는 warp, Amd는 wavefront라는 이름으로 8~64개의 셰이더 코어를 묶어서 SIMD(Single instruction Multiple Data)처리를 한다. 워프 안에서 병렬로 동일한 명령을 같은 단계로 수행. 메모리 인출을 워프가 만나면 다른 워프로 교체. 교체되었던 이전 워프의 메모리 인출이 끝나면 해당워프로 되돌아가 명령을 종료하고 다음 워프로 교체.픽셀 셰이더" }, { "title": "Ustruct", "url": "/posts/ustruct/", "categories": "", "tags": "", "date": "2024-07-12 00:00:00 +0900", "snippet": "" }, { "title": "Assert", "url": "/posts/assert/", "categories": "Unreal Engine, Basic", "tags": "TAG", "date": "2024-07-12 00:00:00 +0900", "snippet": "언리얼 Assert 함수런타임 assert는 기본적으로 DO_CHECK 디파인이 true일 경우 실행 중지, 실행 중지 하지 않고 보고 유형이 있다. DO_GUARD_SLOW일 경우 디버그 빌드에서 실행중지 유형이 있다.DO_CHECK 계열 매크로(실행 중지) check(표현식) 표현식이 false면 실행 중지. 가장 간단한 형태의 매크로. DO_CHECK = 1일때 실행. verify(표현식) DO_CHECK가 켜져있으면 check와 동일한 역할을 함. DO_CHECK가 꺼져있어도 실행은됨. checkf(표현식, …) 표현식이 true가 아니면 디버깅에 도움이 되는 추가 정보 출력이 되는게 가능. verifyf(표현식, …) verify와 비슷하게동작. 디버그 메시지 출력 가능. checkCode(표현식){…} 한 번 실행되는 do/while 루프 안에서 표현 식 실행. 자주 쓰이지는 않음. check처럼 DO_CHECK가 0이면 실행되지 않음. checkCode( if( !IsValidChecked(Object) ) { UE_LOG(LogUObjectGlobals, Fatal, TEXT(&quot;Object %s is part of root set though is invalid!&quot;), *Object-&amp;gt;GetFullName() ); } ); checkNoEntry() 표현식을 받지 않으며, 절대 실행 될 일이 없는 코드 경로를 표시하는데 사용. switch (MyEnum) { case MyEnumValue: break; default: checkNoEntry(); break; } checkNoReentry() 호출이 주어진 함수에 재진입하는 것을 방지하기 위해 사용 void NOReentry() { checkNoReentry(); } checkNoRecursion() checkNoReentry와 같은 검사를 한다. int32 Recurse(int32 a, int32 B) { checkNoRecursion(); return Recurse(A - 1, B - 1); } unimplemented() 함수에 구현이 없어서 특정 클래스에서 호출하면 안되거나 덮어써야 하는 함수를 표시하는데 사용 class FNoImpl { virtual void Dostuff() { // You must override this unimplemented(); } } DO_CHECK가 0으로 되어있을 경우 매크로 ensure(표현식) 표현식을 검증하여 실패하면 그 지점까지 이르는 콜스택 생성 { if (ensure(Inobject != NULL)) { Inobject-&amp;gt;Modify(); } } ensureMsg(표현식, 메시지) 표현식을 검증, 리포트에 메시지를 추가시킨 콜스택을 형성 ensureMsg(Node != nullptr, TEXT(&quot;Node is invalid&quot;)); ensureMsgf(표현식, 메시지, …) 메시지에 상세정보 포함시킴 if (ensureMsgf(!bModal, TEXT(&quot;Could not create dialog because modal is set to (%d)&quot;, int32(bModal)))) { //... } DO_GUARD_SLOW 계열 매크로각각 짝지어 있는 DO_CHECK계열의 버전과 동작은 똑같다. Development 혹은 shipping 버전에서는 사용되지 않는다. checkSlow() checkfSlow() verifySlow()" }, { "title": "Interface, TSubclassOf", "url": "/posts/interface_Tsubclass/", "categories": "Unreal Engine, Basic", "tags": "TAG", "date": "2024-07-11 00:00:00 +0900", "snippet": "언리얼 Interface 개요 자바 등에서 사용하는 인터페이스와 같은 개념이다. 서로 관련이 없는 여러 클래스에서 공통적인 유틸리티 함수 세트가 필요할때, 인터페이스 클래스를 이용하면 된다. 인터페이스 클래스는 UCLASS 대신 UINTERFACE매크로를 사용한다. 실제 인터페이스가 아니라 언리얼 리플렉션 시스템에 등록하기 위한 비어있는 클래스이다. 실제 클래스는 I로 시작하는 이름으로 바뀐다. 순수 가상 함수를 지원한다는데 개인적으로 일반적인 객체지향 프로그래밍에서 말하는 인터페이스를 생각한다면 순수 가상함수만 쓰는게 맞다고 생각한다. 다음의 코드는 인터페이스를 정의 후 특정 클래스에서 상속받은 구조이다.TSubClass UCLASS 유형의 타입 안전성을 보장해준다. UPROPERTY로 에디터에 노출되었을시 지정된 타입 클래스만 노출되도록 할 수 있다. 호환되지 않는 TSubClassOf끼리 할당하면 컴파일 타임에 에러가 난다고 공식 문서에는 안내하고 있는데, 실제로는 컴파일 타임에 에러가 나지 않았다. 할당하는 과정에서 암시적 변환에 성공했기 때문으로 판단된다." }, { "title": "CDO", "url": "/posts/cdo/", "categories": "Unreal Engine, Basic", "tags": "TAG", "date": "2024-07-09 00:00:00 +0900", "snippet": "언리얼 CDO란 무엇인가?언리얼을 컴파일 하는 타임에 클래스의 메타 데이터가 UCLASS에 담긴다. 이는 런타임의 클래스의 타입의 빠른 체크와 검색을 위함이다.언리얼 실행 초기에 언리얼 오브젝트마다 클래스 정보와 언리얼 오브젝트의 인스턴스가 생성된다.이 인스턴스를 CDO라고 한다. CDO는 언리얼 오브젝트의 기본 세팅을 가지고 있는 일종의 템플릿이다.CDO 사용시 이점, 특징은 다음과 같다. 언리얼 엔진은 클래스의 모든 인스턴스에 대해 동일한 기본 값을 저장하는 대신 CDO에 한번만 저장한다. 인스턴스 생성시 기본값은 CDO를 참조하면 되기에 초기화 비용에서 이점을 누릴 수 있다. 모든 오브젝트가 동일한 기본 값 설정을 가지게 되므로 일관성이 생긴다. 클래스의 기본 속성을 변경하려는 경우 CDO의 기본 값을 변경하면 모든 인스턴스에 대해 전역적으로 값을 적용시킬 수 있다. 예시 : ACharacter라는 언리얼 클래스가 있다면, ACharacter 객체가 가지고 있는 고유의 Health, Damage등의 속성은 CDO에 보관된다. 생성되는 모든 ACharacter는 CDO에 지정된 기본값을 사용하게 된다.엔진 코드에서 CDO를 사용하여 코드를 작성한 사례AActor* UWorld::SpawnActor에서는 Actor를 생성하기 전에 CDO를 참조하여 parameter로 넘겨준다.내부에서는 CDO를 참조하여 재사용 가능한 객체인지 판단하고 메모리 할당후 객체를 초기화한다." }, { "title": "Lamda식", "url": "/posts/Unreal_lamda/", "categories": "Unreal Engine, Basic", "tags": "TAG", "date": "2024-07-08 00:00:00 +0900", "snippet": "lambda,closure, capture에 대해 설명하라. (c++과 다른 언어 비교 설명) c++ 람다 표현식은 기본적으로 함수의 형태를 띄지만 함수의 이름은 존재하지 않고 시그니처(리턴 값과 파라메터 등)만 존재하는 함수식이다. 기본 표현 방법은 다음과 같다. [capture](paratmeter)-&amp;gt;returnType{statement}(argument) 각 항목에 대한 설명은 다음과 같다. Capture : 어떤 식으로 람다 식 안에서 람다 밖의 변수를 접근할지 결정한다. [] : 람다 바깥쪽 변수를 캡처하지 않는다 [&amp;amp;](){ /* */} : 외부 모든 변수를 call by reference로 가져온다 [=](){ /* */} : 외부 모든 변수를 call by value로 가져온다 [a, &amp;amp;b] : a는 call by value로, b는 Call by reference로 가져온다 parameter : 매개변수 없을시 생략가능 return Type : -&amp;gt;int와 같은 식으로 명시. 반환 값 없을시 생략 가능 statement : 함수 본문 argument : 전달 인자 값. 전달인자 없을시 생략 가능 람다식은 ‘함수성의 틀’과 같은 것이고 closure는 람다식을 통해 런타임에 생성된 임시 객체이다. auto f = [&amp;amp;](int x, int y) { return fudgeFactor * (x + y); }; 해당 식에서 우측의 람다식을 통해서 클로저 객체가 생성이 되고, 이 객체는 f에 카피된다. 생성된 클로저 객체는 라인의 끝에서 소멸된다. 람다와 클로저의 차이는 클래스와 클래스 인스턴스의 차이라고 보면 된다. c# 식이 본문으로 포함된 람다 : (input-parameters) =&amp;gt; expression 문장 블록이 본문으로 포함된 람다 : input-parameters =&amp;gt; { / / } c++과의 차이점 캡처 형식 따로 명시 해줄 필요 없음. 람다의 대리자가 가비지 컬렉션에 수집될때까지 캡처 변수 값은 가비지 컬렉션안됨 리턴 타입 명시할 필요 없음 Java의 람다 기본 문법 : (parameter) -&amp;gt; statement c++과의 차이점 지역변수를 캡처한다면 final(c++로 치면 const)로 사용해야 한다. final로 선언되어 있지 않다고 하더라도 캡처 하는 값의 재할당이 일어나면 안됨. " }, { "title": "Delegate", "url": "/posts/Unreal_delegate/", "categories": "Unreal Engine, Basic", "tags": "TAG", "date": "2024-07-08 00:00:00 +0900", "snippet": "델리게이트는 무엇인가델리게이트란 대리자라는 뜻으로서 함수를 바인딩하는 형태로 등록하여 콜백함수처럼 사용 할 수 있다. 다음 예시를 보자.BoxComp의 OnComponentHit 이벤트가 발생하면, 바인딩 되어있는 AOnComponentHit::OnComponentHit가 호출되는 것이다.파라메터의 갯수에 따라서 One_param, Two_Param 등으로 선언해야한다. 최대 8개까지의 파라메터가 가능하다.총 4가지 종류의 delegate가 있다. 기본적으로 델리게이트를 더 이상 사용하지 않는 시점에는 UnBind해야 한다. 싱글 캐스트 - 가장 기본적인 델리게이트. 함수 1개가 바인드 된다 멀티 캐스트 - 싱글 캐스트와 동일하지만 여러 함수를 바인드 된다. 델리게이트 실행시 바인드 된 모든 함수들이 호출된다. 이벤트 - 멀티 캐스트와 동일하지만 전역으로 설정할 수 없다. 다이나믹 - 싱글 ,멀티 두가지가 존재한다. 델리게이트가 블루프린트에 노출된다. UPROPERTY 속성을 줘야 한다.델리게이트에 바인딩 할 함수 종류에 따라 API를 구분하여 사용하여야한다. 전역 C++ 함수 : BindStatic API를 사용해 등록 전역 C++ 람다 함수 : BindLambda API를 사용해 등록 C++클래스 멤버 함수 : BindRaw API를 사용해 등록 공유포인터 클래스의 멤버 함수 (쓰레드 미지원) : BindSP API를 사용해 등록 공유포인터 클래스의 멤버 함수 (쓰레드 지원) : BindThreadSafeSP API를 사용해 등록 UFUNCTION 멤버 함수 : BindUFunction API를 사용해 등록 언리얼 오브젝트의 멤버함수 : BindUObject API를 사용해 등록만약 델리게이트를 Bind한 함수의 객체가 Destroy된 상태에서 해당 델리게이트를 호출하면 어떻게 되는가?A객체의 멤버함수를 바인딩 후, A 객체가 삭제될시 IsBound() 체크를 하지 않고서 델리게이트를 직접 호출해 보았다.액세스 위반이 발생하는 것을 확인했다. 쓰레기 값을 호출하기 떄문일 것이다.참고: ue4_delegate예시, ue4_delegate 바인드 종류" }, { "title": "형변환", "url": "/posts/unrealType/", "categories": "Unreal Engine, Basic", "tags": "TAG", "date": "2024-07-05 00:00:00 +0900", "snippet": "언리얼 형변환은 어떻게 이루어지는가? c++ 언리얼은 기본적으로Cast를 사용하여 형변환을 진행한다. 이 Cast는 UObject 타입에 대해서만 쓰이고 타입 안정성을 지닌다. 유효하지 않은 casting에 대해선 (ex:상속구조가 다르다거나) nullptr을 리턴한다는 이야기이다. 기본적으로 Cast를 썼을때, 내부적으로는 C 스타일의 캐스팅으로 변환이 된다. 따라서 const_cast와 static_cast는 자연적으로 일어난다. if constexpr (TIsIInterface&amp;lt;From&amp;gt;::Value) { if (UObject* Obj = Src-&amp;gt;_getUObject()) { if constexpr (TIsIInterface&amp;lt;To&amp;gt;::Value) { return (To*)Obj-&amp;gt;GetInterfaceAddress(To::UClassType::StaticClass()); } else { if (Obj-&amp;gt;IsA&amp;lt;To&amp;gt;()) { return (To*)Obj; } } } } reinterpret_cast처럼 동작하는 경우는 없다. TCastFlags 내부 로직을 보면, 언리얼 리플렉션 시스템에 등록된 연관성이 있는 클래스끼리 검사를 한다. 따라서 상속 구조상 연관 성이 없는 타입의 포인터 변환은 허용되지 않는 것이다. blueprint Cast To node를 통해 형변환이 가능하다. 기본적으로 언리얼 c++ 처럼 상속구조상 유효한 타입만을 형변환 할 수 있다. 언리얼 엔진은 C++ 기본 RTTI 사용하는지? 사용하지 않는다면 왜 그런가?언리얼은 c++ 기본 RTTI를 사용하지 않는다. RTTI라는 개념은 런타임에 특정 타입의 정보(크기, 타입명 등)을 얻어오는 것인데, 이것 자체가 비용이 비싸다. 언리얼은 프로퍼티 시스템은 리플렉션을 활용하고 있다. UCLASS, USTRUCT, UPROPERTY등의 매크로를 통해 UOBJECT 계열 타입들에 대한 정보가 수집되어 있다." }, { "title": "형변환, c++11기타", "url": "/posts/cpp/", "categories": "C++", "tags": "TAG", "date": "2022-10-17 00:00:00 +0900", "snippet": "C++ 기존 형변환 Cast에는 어떤 것들이 있나? static_cast가장 기본적인 캐스팅. C 스타일 캐스팅과 다를 바 없어 보이나 형변환이 불가능한 타입으로 캐스팅 시에는 컴파일 단에서 에러를 발생시킨다. 번거롭더라도 C스타일의 캐스팅은 지양하고, 기본적으로 static_cast를 사용하는 것이 좋다. dynamic cast상속 구조에서 안전한 다운캐스팅을 지원한다. 유효하지 않은 캐스팅일 경우에는 nullptr을 반환한다. 런타임 비용이 크기 때문에 일반적으로 추천되지 않는다. 부모-&amp;gt; 자식 관계를 명확하게 알고 static_cast를 사용하는 것이 더 바람직하다. const cast상수성을 없애는 캐스트. reinterpret_cast임의의 포인터끼리의 변환을 허용한다. 또한 정수형을 포인터로 변환하여 준다. 사용시 각별한 주의가 필요하다. RTTI는 무엇인가?Run Time Type information의 약자이다. 런타임 도중 실제 타입의 정보를 얻어오는데 사용된다.dynamic_cast가 해당 기술을 이용해 내부적으로 구현되고 있다고 한다. 가상 테이블이란 무엇인가? 최대한 자세히 설명하라.상속 구조에서 가상함수 정의된 클래스가 만들어져 있다면 가상함수 테이블이 생성된다. NULL과 nullptr의 차이는?NULL은 define 된 값으로서 그 정의를 따라가보면 0으로 체크되어있다. 따라서 포인터값만을 비교하기 위한 것이 아닌 정수값으로도 비교가 가능하다. 반면 nullptr은 포인터 타입의 좀더 정확한 체크를 위해 c++11부터 도입된 타입으로서 포인터 타입이 아닌 다른곳에 비교했을땐 컴파일 에러가 난다. 기본적으로 포인터 체크를 위해선 nullptr을 사용하는 것이 좋다. varient에 대해 설명하라.컴파일 타임에 정해진 여러가지 객체 중에 하나의 타입을 보관할 수 있는 클래스이다. 공용체(union)과 비슷하지만 union은 현재 어떤 타입의 객체를 보관하고 있는지 알 수 없다. " }, { "title": "언리얼 첫번째글!", "url": "/posts/Unreal/", "categories": "Unreal Engine, Study", "tags": "TAG", "date": "2022-06-06 00:00:00 +0900", "snippet": "This is an H1" }, { "title": "c++ 첫번째글!", "url": "/posts/cpp/", "categories": "C++", "tags": "TAG", "date": "2022-06-06 00:00:00 +0900", "snippet": "Cpp 첫번째" } ]
