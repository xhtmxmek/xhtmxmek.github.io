---
title: 그래픽 처리 장치
#date: 2024-10-02 14:51:00 +0800
categories: [Graphics_3D, Real Time Rendering]
tags: [TAG]		# TAG는 반드시 소문자로 이루어져야함!
---

## **3장 그래픽 처리 장치**


모든 처리가 해결해야 하는 문제는 지연(latency)이다. 기본 개념은 처리할 정보가 처리장치에서 멀어질수록 대기 시간이 길어진다.(예를 들어 컴퓨트 셰이더의 경우, 장치메모리 > 공유 메모리 > 레지스터 순으로 속도가 빨라진다).
데이터 검색을 기다려서 처리장치가 정지 대기(stall)가 되어 성능이 떨어지는 것이 요점이다.


### 데이터 병렬 아키텍처

CPU는 제한된 SIMD 벡터 처리를 제외하고는 대부분 직렬 방식으로 실행. 캐시나 분기예측 등으로 정지 대기를 방지함.
GPU는 CPU와 다르게 수천개의 코어로 이루어져 있음. 대규묘 유사한 데이터 집합을 병렬로 처리함. cpu와 다르게 캐시 메모리와 제어 로직 전용 칩 영역이 적어서 지연 시간이 cpu보다 높다.
단일 코어를 지닌 gpu에서, 2000개의 프래그먼트를 처리한다고 가정하자. 셰이더 프로그램 역시 2000번실행된다. 텍스처 샘플링 할떄, 메모리 fetch 연산은 수백에서 수천 클럭 주기를 소모하며 이 시간동안 GPU 처리장치는 아무것도 하지 않음. 이 시점 셰이더 프로세서는 반환 끝날때까지 대기. 

이를 개선하기 위해 정지(stall) 명령을 만나면 2번째 프래그먼트로 전환하여 셰이더 프로그램 실행. 산술연산 실행하고 텍스처 페치 만나면 다시 멈추고 3번째 프래그먼트로 감. 첫번째 프래그먼트 인출이 끝나면 첫번째로 다시 되돌아감.
nvidia는 warp, Amd는 wavefront라는 이름으로 8~64개의 셰이더 코어를 묶어서 SIMD(Single instruction Multiple Data)처리를 한다. 워프 안에서 병렬로 동일한 명령을 같은 단계로 수행. 메모리 인출을 워프가 만나면 다른 워프로 교체. 교체되었던 이전 워프의 메모리 인출이 끝나면 해당
워프로 되돌아가 명령을 종료하고 다음 워프로 교체
![셰이더_프로그램](/assets/img/realTimeRendering/gpu_shaderProgram.png)

셰이더 프로그램 별로 필요한 레지스터와 공유메모리가 많을수록 더 적은 스레드, 즉 더 적은 워프가 GPU에 거주할 수 있다.GPU에 거주하는 warp가 적다는 것은 워프의 치환으로도 완화시킬수 없는 정지 대기가 발생한다는 것을 의미한다. 거주중인 워프를 in flight라고 하고, 그 수를 점유율(occpuacy)라고 한다. 높은 점유율은 쉬는 처리 장치가 적을 가능성이 높다. 

점유율에 관한 참고 링크
[점유율](https://logins.github.io/graphics/2020/10/31/D3D12ComputeShaders.html)

점유율에 대한 핵심 개념은, GPU별로 가지고 있는 스트리밍 멀티프로세서당 최대한 많은 warp를 올리는 것. 많은 warp를 올릴려면 위 링크에 명시된 gpu 아키텍처의 SM가 수용할 수 있는 공유 메모리의 사이즈나 최대 스레드 수 등을 고려해야됨. 특히 컴퓨트 셰이더를 사용할때, 그룹의 크기를 너무 크게 잡는다거나 공유 메모리 크기를 너무 크게 잡는다거나 하면 SM에 올릴 수 있는 warp의 숫자가 적어져서 놀게 되는 sm이 생기고 처리되지 못하는 스레드들이 생김. 이것은 좋지 않음.


동적 분기 또한 점유율에 영향을 준다. if문과 반복문으로 인해 발생한다. 처리되지 않는 분기나 루프에 대해서도 워프는 반드시 해당 분기까지 실행을하고 불필요한 결과를 버린다. 버려진 경로에 대해서는 유휴 상태(idle)이 된다.