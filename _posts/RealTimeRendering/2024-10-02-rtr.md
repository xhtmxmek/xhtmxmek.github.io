---
title: RealTimeRendering
#date: 2024-10-02 14:51:00 +0800
categories: [Graphics_3D, Real Time Rendering]
tags: [TAG]		# TAG는 반드시 소문자로 이루어져야함!
---

## **3장 그래픽 처리 장치**


모든 처리가 해결해야 하는 문제는 지연(latency)이다. 기본 개념은 처리할 정보가 처리장치에서 멀어질수록 대기 시간이 길어진다.(예를 들어 컴퓨트 셰이더의 경우, 장치메모리 > 공유 메모리 > 레지스터 순으로 속도가 빨라진다).
데이터 검색을 기다려서 처리장치가 정지 대기(stall)가 되어 성능이 떨어지는 것이 요점이다.


### 데이터 병렬 아키텍처

CPU는 제한된 SIMD 벡터 처리를 제외하고는 대부분 직렬 방식으로 실행. 캐시나 분기예측 등으로 정지 대기를 방지함.
GPU는 CPU와 다르게 수천개의 코어로 이루어져 있음. 대규묘 유사한 데이터 집합을 병렬로 처리함. cpu와 다르게 캐시 메모리와 제어 로직 전용 칩 영역이 적어서 지연 시간이 cpu보다 높다.
단일 코어를 지닌 gpu에서, 2000개의 프래그먼트를 처리한다고 가정하자. 셰이더 프로그램 역시 2000번실행된다. 텍스처 샘플링 할떄, 메모리 fetch 연산은 수백에서 수천 클럭 주기를 소모하며 이 시간동안 GPU 처리장치는 아무것도 하지 않음. 이 시점 셰이더 프로세서는 반환 끝날때까지 대기. 

이를 개선하기 위해 정지(stall) 명령을 만나면 2번째 프래그먼트로 전환하여 셰이더 프로그램 실행. 산술연산 실행하고 텍스처 페치 만나면 다시 멈추고 3번째 프래그먼트로 감. 첫번째 프래그먼트 인출이 끝나면 첫번째로 다시 되돌아감.
nvidia는 warp, Amd는 wavefront라는 이름으로 8~64개의 셰이더 코어를 묶어서 SIMD(Single instruction Multiple Data)처리를 한다. 워프 안에서 병렬로 동일한 명령을 같은 단계로 수행. 메모리 인출을 워프가 만나면 다른 워프로 교체. 교체되었던 이전 워프의 메모리 인출이 끝나면 해당
워프로 되돌아가 명령을 종료하고 다음 워프로 교체.


### 픽셀 셰이더